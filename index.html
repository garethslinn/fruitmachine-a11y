<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./src/styles/main.css" />
    <title>Canvas Slot Machine</title>
    <style>
        /* CSS for nudge-active state: yellow flash for nudges */
        .nudge-active {
            background-color: yellow !important;
            color: black !important;
        }
        /* CSS for hold-active state */
        .hold-active {
            background-color: green !important;
            color: white !important;
        }
        /* CSS for flashing hold buttons */
        .hold-flash {
            animation: flash 0.5s infinite alternate;
        }
        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.5; }
        }
        /* Hide the Confirm button from view but keep it functional */
        #confirmButton {
            display: none;
        }
    </style>
</head>
<body>
<div id="creditDisplay" style="margin-bottom: 1rem; font-size: 1.5rem; height: 2rem">
    Credits: <span id="creditCount">£10.00</span>
</div>
<!-- Win / Nudge notice -->
<div id="winNotice" style="font-size: 1.5rem; margin-bottom: 1rem;"></div>

<span class="wrapper">
    <img src="overlay.svg" id="canvasOverlay" />
    <canvas id="slotCanvas" width="500" height="300"></canvas>
  </span>

<!-- Control buttons -->
<div class="button-row">
    <button id="startButton">Start</button>
    <button id="winSpinButton">Win Spin</button>
    <button id="confirmButton" disabled>Confirm</button>
    <button id="resetCreditButton">Reset Credits</button>
    <button id="cancelButton">Cancel</button>
    <button id="soundToggle">Sound: On</button>
</div>

<!-- Hold buttons (default text "Hold") -->
<div class="controls">
    <button id="hold1" disabled>Hold</button>
    <button id="hold2" disabled>Hold</button>
    <button id="hold3" disabled>Hold</button>
    <button id="hold4" disabled>Hold</button>
</div>

<script>
    const canvas = document.getElementById("slotCanvas");
    const ctx = canvas.getContext("2d");

    // Image paths for reels
    const imagePaths = [
        "src/images/01.svg",
        "src/images/02.svg",
        "src/images/04.svg",
        "src/images/10.svg",
        "src/images/09.svg",
        "src/images/05.svg",
        "src/images/08.svg"
    ];

    const reelCount = 4;
    const reelImages = imagePaths.length;
    const reelHeight = 80;
    const reelWidth = 100;
    const imageGap = 10;
    const winLineY = 90;
    const spinDurations = [600, 1200, 1800, 2400];

    // Payout table (in pounds)
    const fruitmachinePayouts = {
        cherry: { reel1: 0.20, reel2: 0.40, reel3: 0.80, reel4: 2.00 },
        lemon:  { reel3: 0.80, reel4: 3.00 },
        plum:   { reel3: 0.80, reel4: 5.00 },
        triple: { reel3: 5.00, reel4: 100.00 },
        double: { reel3: 3.00, reel4: 50.00 },
        melon:  { reel3: 1.00, reel4: 10.00 },
        single: { reel3: 2.00, reel4: 25.00 }
    };

    // Mapping from image path to symbol name.
    const symbolMap = {
        "src/images/01.svg": "cherry",
        "src/images/02.svg": "lemon",
        "src/images/04.svg": "plum",
        "src/images/10.svg": "triple",
        "src/images/09.svg": "double",
        "src/images/05.svg": "melon",
        "src/images/08.svg": "single"
    };

    function getPayout(symbol, reelCount) {
        const payoutData = fruitmachinePayouts[symbol];
        return payoutData ? payoutData[`reel${reelCount}`] || 0 : 0;
    }

    console.log(getPayout("cherry", 4)); // 2.00
    console.log(getPayout("lemon", 3));  // 0.80

    // Preload images
    let images = [];
    let imagesLoaded = 0;
    imagePaths.forEach((src, index) => {
        images[index] = new Image();
        images[index].src = src;
        images[index].onload = () => {
            imagesLoaded++;
            if (imagesLoaded === imagePaths.length) {
                console.log("All images loaded successfully.");
                drawReels();
            }
        };
        images[index].onerror = () => {
            console.error(`Failed to load image: ${src}`);
        };
    });

    function adjustCanvasResolution() {
        const scale = window.devicePixelRatio || 1;
        canvas.width = 500 * scale;
        canvas.height = 300 * scale;
        ctx.scale(scale, scale);
    }
    adjustCanvasResolution();

    // Create a reel sequence for each reel.
    let reelSequences = Array.from({ length: reelCount }, () => [...imagePaths]);
    let reels = Array.from({ length: reelCount }, (_, i) => ({
        position: Math.floor(Math.random() * reelImages) * (reelHeight + imageGap),
        speed: Math.random() * 40 + 20,
        spinning: false,
        stopAt: 0
    }));

    let spinning = false;
    let holdStatus = [false, false, false, false];

    // Global nudges per spin – 3 nudges available.
    let nudgesRemaining = 3;

    const startButton = document.getElementById("startButton");
    const winSpinButton = document.getElementById("winSpinButton");
    const confirmButton = document.getElementById("confirmButton");
    const resetCreditButton = document.getElementById("resetCreditButton");
    const cancelButton = document.getElementById("cancelButton");
    const holdButtons = [
        document.getElementById("hold1"),
        document.getElementById("hold2"),
        document.getElementById("hold3"),
        document.getElementById("hold4")
    ];

    // Initialize credits from localStorage or default to £10.00.
    let credits = parseFloat(localStorage.getItem('credits')) || 10.00;
    const creditCountElement = document.getElementById("creditCount");
    function updateCreditDisplay() {
        creditCountElement.textContent = `£${credits.toFixed(2)}`;
    }
    updateCreditDisplay();

    // Reset credits to default (£10.00).
    resetCreditButton.addEventListener("click", () => {
        credits = 10.00;
        localStorage.setItem('credits', credits);
        updateCreditDisplay();
        startButton.disabled = false;
    });

    // Global sound state.
    let soundEnabled = true;
    const soundToggleButton = document.getElementById("soundToggle");
    soundToggleButton.addEventListener("click", () => {
        soundEnabled = !soundEnabled;
        soundToggleButton.textContent = soundEnabled ? "Sound: On" : "Sound: Off";
    });

    function playReelSound() {
        if (!soundEnabled) return;
        let audio = new Audio("reel.mp3");
        audio.play();
    }
    function playWinSound() {
        if (!soundEnabled) return;
        let audio = new Audio("win.mp3");
        audio.play();
    }

    // While spinning, disable hold buttons.
    function resetHoldButtons() {
        holdStatus.fill(false);
        nudgesRemaining = 3;
        holdButtons.forEach((button) => {
            button.disabled = true;
            button.textContent = "Hold";
            button.classList.remove("hold-active", "hold-flash", "nudge-active");
        });
        confirmButton.disabled = true;
    }

    // Helper: Check if all 4 reels match.
    function checkFourReelWin() {
        const symbols = getWinningSymbols();
        return symbols.every(symbol => symbol === symbols[0]);
    }

    // After spin, if credits > £1, enable hold buttons for nudging indefinitely.
    // When a button is clicked, its text changes to "Nudge" (with .nudge-active styling),
    // a nudge is applied, nudgesRemaining is decremented, and the win line is checked.
    // If a win is detected, update credits, announce win, set nudgesRemaining to 0, and reset the game.
    function enableHoldButtonsForNudging() {
        const winNotice = document.getElementById("winNotice");
        winNotice.textContent = `Nudges available: ${nudgesRemaining}`;
        holdButtons.forEach((button, index) => {
            button.disabled = false;
            button.classList.add("hold-flash");
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            holdButtons[index] = newButton;
            newButton.addEventListener("click", () => {
                if (nudgesRemaining > 0) {
                    nudgesRemaining--;
                    newButton.textContent = "Nudge";
                    newButton.classList.add("nudge-active");
                    winNotice.textContent = `Nudges available: ${nudgesRemaining}`;
                    // Apply a nudge on the corresponding reel.
                    reels[index].position -= (reelHeight + imageGap);
                    if (reels[index].position < 0) {
                        reels[index].position += reelImages * (reelHeight + imageGap);
                    }
                    drawReels();
                    setTimeout(() => {
                        newButton.textContent = "Hold";
                        newButton.classList.remove("nudge-active");
                        // Check win after each nudge.
                        const winningSymbols = getWinningSymbols();
                        const winAmount = computeWin(winningSymbols);
                        if (checkFourReelWin() || winAmount > 0) {
                            // Win detected: update credits, announce win, and reset nudges.
                            disableHoldButtons();
                            credits += winAmount;
                            localStorage.setItem('credits', credits);
                            updateCreditDisplay();
                            showWinNotice(winAmount);
                            nudgesRemaining = 0;
                            setTimeout(() => {
                                clearWinNotice();
                                resetHoldButtons();
                            }, 1000);
                        }
                    }, 1000);
                }
            });
        });
        confirmButton.disabled = false;
    }

    // When the user clicks Confirm (or it's auto-triggered), disable hold buttons and compute win.
    confirmButton.addEventListener("click", () => {
        disableHoldButtons();
        const winningSymbols = getWinningSymbols();
        const winAmount = computeWin(winningSymbols);
        if (winAmount > 0) {
            showWinNotice(winAmount);
            setTimeout(() => {
                credits += winAmount;
                localStorage.setItem('credits', credits);
                updateCreditDisplay();
                clearWinNotice();
            }, 500);
        }
        resetHoldButtons();
    });

    // Disable hold buttons.
    function disableHoldButtons() {
        holdButtons.forEach((button) => {
            button.disabled = true;
            button.classList.remove("hold-flash");
        });
        confirmButton.disabled = true;
    }

    function drawReels() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < reelCount; i++) {
            let x = i * (reelWidth + 28) + 10;
            for (let j = 0; j < reelImages + 2; j++) {
                let imgIndex = (Math.floor(reels[i].position / (reelHeight + imageGap)) + j) % reelImages;
                let imgName = reelSequences[i][imgIndex];
                let y = (j * (reelHeight + imageGap)) - (reels[i].position % (reelHeight + imageGap)) - (reelHeight + imageGap);
                if (images[imagePaths.indexOf(imgName)]) {
                    ctx.drawImage(images[imagePaths.indexOf(imgName)], x, y, reelWidth, reelHeight);
                }
            }
            // Uncomment to visualize the win line:
            // ctx.strokeStyle = "red";
            // ctx.lineWidth = 3;
            // ctx.strokeRect(x, winLineY, reelWidth, reelHeight);
        }
    }

    function getWinningSymbols() {
        let winningSymbols = reels.map((reel, i) => {
            let offset = Math.round(reel.position / (reelHeight + imageGap));
            let winningIndex = (offset + 2) % reelImages;
            return reelSequences[i][winningIndex];
        });
        console.log("🎉 Winning Symbols on the Win Line:", winningSymbols);
        return winningSymbols;
    }

    function computeWin(symbols) {
        const baseSymbolImage = symbols[0];
        const baseSymbol = symbolMap[baseSymbolImage] || baseSymbolImage;
        let count = 1;
        for (let i = 1; i < symbols.length; i++) {
            const currentSymbol = symbolMap[symbols[i]] || symbols[i];
            if (currentSymbol === baseSymbol) count++;
            else break;
        }
        console.log("baseSymbol, count", baseSymbol, count);
        return getPayout(baseSymbol, count);
    }

    function showWinNotice(amount) {
        const winNotice = document.getElementById("winNotice");
        winNotice.textContent = `You won £${amount.toFixed(2)}!`;
        playWinSound();
    }

    function clearWinNotice() {
        document.getElementById("winNotice").textContent = "";
    }

    // spinReels accepts a forceWin flag.
    // In win spin mode, reels 0–2 are forced to a common symbol,
    // and reel 3 is forced to a different symbol.
    function spinReels(forceWin = false) {
        spinning = true;
        holdButtons.forEach((button) => button.disabled = true);
        nudgesRemaining = 3;
        holdStatus = [false, false, false, false];

        const startTime = Date.now();
        let winSymbol = null;
        let winIndex = null;
        if (forceWin) {
            winIndex = Math.floor(Math.random() * reelImages);
            winSymbol = reelSequences[0][winIndex];
        }
        reels.forEach((reel, index) => {
            if (!holdStatus[index]) {
                reel.spinning = true;
                reel.speed = Math.random() * 50 + 50;
                reel.stopAt = startTime + spinDurations[index];
                if (forceWin) {
                    if (index < 3) {
                        reel.position = winIndex * (reelHeight + imageGap);
                    }
                    // For reel 3, we'll force it later.
                }
            }
        });

        function animate() {
            let stillSpinning = false;
            const currentTime = Date.now();
            reels.forEach((reel, index) => {
                if (reel.spinning) {
                    stillSpinning = true;
                    let timeRemaining = reel.stopAt - currentTime;
                    let totalSpinTime = spinDurations[index];
                    if (timeRemaining < totalSpinTime * 0.1) {
                        reel.speed *= 0.80;
                    } else {
                        reel.speed *= 0.99;
                    }
                    reel.position -= reel.speed;
                    if (currentTime >= reel.stopAt) {
                        reel.spinning = false;
                        reel.speed = 0;
                        reel.position = Math.round(reel.position / (reelHeight + imageGap)) * (reelHeight + imageGap);
                        if (forceWin) {
                            if (index < 3) {
                                reel.position = winIndex * (reelHeight + imageGap);
                            } else if (index === 3) {
                                let diffIndices = [];
                                for (let i = 0; i < reelImages; i++) {
                                    if (i !== winIndex) diffIndices.push(i);
                                }
                                let forcedIndex = diffIndices[Math.floor(Math.random() * diffIndices.length)];
                                reel.position = forcedIndex * (reelHeight + imageGap);
                            }
                        }
                    }
                    if (reel.position < 0) {
                        reel.position = (reelImages - 1) * (reelHeight + imageGap);
                    }
                }
            });
            drawReels();
            if (stillSpinning) {
                requestAnimationFrame(animate);
            } else {
                spinning = false;
                // Immediately update the win line.
                const winningSymbols = getWinningSymbols();
                const winAmount = computeWin(winningSymbols);
                // If a win is detected after the spin, immediately pay it out and reset.
                if (winAmount > 0) {
                    disableHoldButtons();
                    credits += winAmount;
                    localStorage.setItem('credits', credits);
                    updateCreditDisplay();
                    showWinNotice(winAmount);
                    nudgesRemaining = 0;
                    setTimeout(() => {
                        clearWinNotice();
                        resetHoldButtons();
                    }, 1000);
                } else if (credits > 1.00) {
                    // Otherwise, enable unlimited nudging.
                    enableHoldButtonsForNudging();
                }
            }
        }
        animate();
    }

    startButton.addEventListener("click", () => {
        if (!spinning) {
            // Each play costs £0.10.
            if (credits >= 0.10) {
                credits -= 0.10;
                localStorage.setItem('credits', credits);
                updateCreditDisplay();
                if (credits < 0.10) {
                    startButton.disabled = true;
                }
                playReelSound();
                spinReels();
            } else {
                alert("No more credits!");
            }
        }
    });

    winSpinButton.addEventListener("click", () => {
        if (!spinning) {
            spinReels(true);
        }
    });

    cancelButton.addEventListener("click", resetHoldButtons);
    setTimeout(drawReels, 200);
</script>
</body>
</html>
