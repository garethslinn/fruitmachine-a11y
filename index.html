<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Slot Machine</title>
    <style>
        body {
            text-align: center;
            background-color: #222;
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: auto;
            max-height: 80vh;
            background: white;
            border: 4px solid red;
            image-rendering: crisp-edges;
        }

        .controls {
            width: 100%;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            flex: 1;
            max-width: 150px;
            padding: 12px 16px;
            font-size: 1.2rem;
            border: none;
            background-color: #ff4d4d;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            transition: 0.3s ease;
        }

        button:hover {
            background-color: #cc0000;
        }
    </style>
</head>
<body>

<canvas id="slotCanvas" width="500" height="300"></canvas>
<div class="controls">
    <button id="startButton">Start</button>
</div>

<script>
    const canvas = document.getElementById("slotCanvas");
    const ctx = canvas.getContext("2d");

    const reelCount = 4;
    const reelImages = 8;
    const reelHeight = 80;
    const reelWidth = 100;
    const imageGap = 10;
    const winLineY = 90; // âœ… This is the win line

    // âœ… Spin durations for each reel
    const spinDurations = [600, 1200, 1800, 2400];

    // âœ… Image paths
    const imagePaths = [
        "01.svg", "02.svg", "03.svg", "04.svg",
        "05.svg", "06.svg", "07.svg", "08.svg"
    ];

    function playReelSound() {
        let audio = new Audio("reel.mp3");
        audio.play();
    }

    function playWinSound() {
        let audio = new Audio("win.mp3");
        audio.play();
    }

    // âœ… Load images
    const images = [];
    imagePaths.forEach((src, index) => {
        images[index] = new Image();
        images[index].src = src;
    });

    // âœ… Keep reels in a fixed order (no shuffle)
    let reelSequences = Array.from({ length: reelCount }, () => [...imagePaths]);

    // âœ… Reel Data
    let reels = Array.from({ length: reelCount }, (_, i) => ({
        position: Math.floor(Math.random() * reelImages) * (reelHeight + imageGap),
        speed: Math.random() * 40 + 20,
        spinning: false,
        stopAt: 0
    }));

    let spinning = false;

    // âœ… Draw Reels
    function drawReels() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < reelCount; i++) {
            let x = i * (reelWidth + 28) + 10;
            for (let j = 0; j < reelImages + 2; j++) {
                let imgIndex = (Math.floor(reels[i].position / (reelHeight + imageGap)) + j) % reelImages;
                let imgName = reelSequences[i][imgIndex];
                let y = (j * (reelHeight + imageGap)) - (reels[i].position % (reelHeight + imageGap)) - (reelHeight + imageGap);
                if (images[imagePaths.indexOf(imgName)]) {
                    ctx.drawImage(images[imagePaths.indexOf(imgName)], x, y, reelWidth, reelHeight);
                }
            }
            ctx.strokeStyle = "red";
            ctx.lineWidth = 3;
            ctx.strokeRect(x, winLineY, reelWidth, reelHeight);
        }
    }

    // âœ… Extract & Log Winning Symbols at the Win Line
    function getWinningSymbols() {
        let winningSymbols = reels.map((reel, i) => {
            let offset = Math.round(reel.position / (reelHeight + imageGap)); // âœ… Get the closest position
            let winningIndex = (offset + 2) % reelImages; // âœ… Ensure correct alignment
            let winningSymbol = reelSequences[i][winningIndex]; // âœ… Correct image
            return winningSymbol;
        });
        console.log("ðŸŽ‰ Winning Symbols on the Win Line:", winningSymbols);
    }

    // âœ… Spin Reels
    function spinReels() {
        spinning = true;
        const startTime = Date.now();

        reels.forEach((reel, index) => {
            reel.spinning = true;
            reel.speed = Math.random() * 50 + 50;
            reel.stopAt = startTime + spinDurations[index];
        });

        function animate() {
            let stillSpinning = false;
            const currentTime = Date.now();

            reels.forEach((reel) => {
                if (reel.spinning) {
                    stillSpinning = true;
                    let timeRemaining = reel.stopAt - currentTime;
                    let totalSpinTime = spinDurations[reels.indexOf(reel)];

                    if (timeRemaining < totalSpinTime * 0.1) reel.speed *= 0.80;
                    else reel.speed *= 0.99;

                    reel.position -= reel.speed;
                    if (currentTime >= reel.stopAt) {
                        reel.spinning = false;
                        reel.speed = 0;
                        reel.position = Math.round(reel.position / (reelHeight + imageGap)) * (reelHeight + imageGap);
                    }
                    if (reel.position < 0) reel.position = (reelImages - 1) * (reelHeight + imageGap);
                }
            });

            drawReels();

            if (stillSpinning) requestAnimationFrame(animate);
            else {
                spinning = false;
                getWinningSymbols(); // âœ… Logs the correct images at the win line
            }
        }

        animate();
    }

    document.getElementById("startButton").addEventListener("click", () => {
        if (!spinning) {
            playReelSound();
            spinReels();
        }
    });

    setTimeout(drawReels, 100);
</script>
</body>
</html>
